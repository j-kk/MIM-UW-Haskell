-- Program to test parser, automatically generated by BNF Converter.

module Main where

import Prelude
  ( ($)
  , Either(..)
  , Int, (>)
  , String, (++), unlines
  , Show, show
  , IO, (>>), (>>=), mapM_, putStrLn
  , FilePath
  , getContents, readFile, Bool, getChar
  )
import Data.List          ( delete, elem )
import System.Environment ( getArgs )
import System.Exit        ( exitFailure, exitSuccess )
import Control.Monad      ( when )
import Control.Monad.State
    ( Monad(return, (>>=)),
      unless,
      modify,
      evalStateT,
      MonadState(put, get),
      MonadTrans(lift),
      StateT )
import TypeChecking (staticCheck)

import AbsBing ( Program )
import ParBing   ( pProgram, myLexer )
import Logic (interpret)
import Commons(Verbosity)
import System.IO (hPutStrLn, stderr)
import Control.Monad.Except ( runExceptT, ExceptT, runExceptT )


import ErrM

tryRunInterpreter :: Verbosity -> Bool -> String -> IO ()
tryRunInterpreter verbosity static_check_skip s =
  case pProgram (myLexer s) of
    Ok tree -> do
      res <- do
        runExceptT (runInterpreter verbosity static_check_skip tree)
      case res of
        (Left e) -> hPutStrLn stderr e -- Print error
        _ -> return ()
    (Bad s) -> hPutStrLn stderr s

runInterpreter :: Verbosity -> Bool -> Program -> ExceptT String IO ()
runInterpreter verbosity static_check_skip tree = do
  unless static_check_skip (runStaticCheck verbosity tree)
  lift $ hPutStrLn stderr "==== Interpreter ===="
  interpret verbosity tree

runStaticCheck :: Verbosity -> Program -> ExceptT String IO ()
runStaticCheck verbosity tree = do
  lift $ hPutStrLn stderr "==== Static Type Check ===="
  staticCheck verbosity tree

usage :: IO ()
usage = do
  putStrLn $ unlines
    [ "Interpreter supports two input modes:"
    , "  (no arguments)  Parse stdin."
    , "  (files)         Parse content of files."
    , "Following flags are supported:"
    , "  --help          Display this help message."
    , "  -v              Verbose mode."
    , "  -s              Skip static-type check."
    ]
  exitFailure

runFromConsole :: Verbosity -> Bool -> IO ()
runFromConsole verbosity static_check_skip = getContents >>= tryRunInterpreter verbosity static_check_skip

runFromFile :: Verbosity -> Bool -> String -> IO ()
runFromFile verbosity static_check_skip file = readFile file >>= tryRunInterpreter verbosity static_check_skip

type ParserState m = StateT [String] IO m

isPresent :: String -> ParserState Bool
isPresent s = do
    args <- get
    modify (delete s)
    return (s `elem` args)

parser :: ParserState ()
parser = do
  verbosity_enabled <- isPresent "-v"
  static_check_skip <- isPresent "-s"
  let verbosity = if verbosity_enabled then 1 else 0
  is_help <- isPresent "--help"
  args <- get
  if is_help
    then
      lift usage
    else
      case args of
        [] -> lift $ runFromConsole verbosity static_check_skip
        _ -> parseAndRun verbosity static_check_skip

parseAndRun :: Verbosity -> Bool -> ParserState ()
parseAndRun verbosity static_check_skip= do
  args <- get
  case args of
    file:t -> do
      lift $ runFromFile verbosity static_check_skip file
      put t
      parseAndRun verbosity static_check_skip
    _ -> return ()

main :: IO ()
main = do
  args <- getArgs
  evalStateT parser args
  exitSuccess


