-- Haskell module generated by the BNF converter

{-# OPTIONS_GHC -fno-warn-unused-matches #-}

module SkelBing where

import Prelude (($), Either(..), String, (++), Show, show)
import qualified AbsBing

type Err = Either String
type Result = Err String

failure :: Show a => a -> Result
failure x = Left $ "Undefined case: " ++ show x

transIdent :: AbsBing.Ident -> Result
transIdent x = case x of
  AbsBing.Ident string -> failure x

transProgram :: AbsBing.Program -> Result
transProgram x = case x of
  AbsBing.Program topdefs -> failure x

transTopDef :: AbsBing.TopDef -> Result
transTopDef x = case x of
  AbsBing.FnDef type_ ident params block -> failure x

transParam :: AbsBing.Param -> Result
transParam x = case x of
  AbsBing.Param type_ ident -> failure x

transBlock :: AbsBing.Block -> Result
transBlock x = case x of
  AbsBing.Block stmts -> failure x

transStmt :: AbsBing.Stmt -> Result
transStmt x = case x of
  AbsBing.Empty -> failure x
  AbsBing.BStmt block -> failure x
  AbsBing.Decl type_ items -> failure x
  AbsBing.FDecl topdef -> failure x
  AbsBing.CDecl type_ items -> failure x
  AbsBing.Ass ident expr -> failure x
  AbsBing.Incr ident -> failure x
  AbsBing.Decr ident -> failure x
  AbsBing.Ret expr -> failure x
  AbsBing.VRet -> failure x
  AbsBing.While expr stmt -> failure x
  AbsBing.For ident expr1 expr2 stmt -> failure x
  AbsBing.SExp expr -> failure x
  AbsBing.Break -> failure x
  AbsBing.Continue -> failure x
  AbsBing.Println expr -> failure x
  AbsBing.Print expr -> failure x
  AbsBing.CondS expr block -> failure x
  AbsBing.CondE expr block1 block2 -> failure x
  AbsBing.CondC expr block econd -> failure x

transItem :: AbsBing.Item -> Result
transItem x = case x of
  AbsBing.NoInit ident -> failure x
  AbsBing.Init ident expr -> failure x

transECond :: AbsBing.ECond -> Result
transECond x = case x of
  AbsBing.ECondS expr block -> failure x
  AbsBing.ECondE expr block1 block2 -> failure x
  AbsBing.ECondC expr block econd -> failure x

transType :: AbsBing.Type -> Result
transType x = case x of
  AbsBing.Int -> failure x
  AbsBing.Str -> failure x
  AbsBing.Bool -> failure x
  AbsBing.Void -> failure x
  AbsBing.Fun type_ types -> failure x

transArg :: AbsBing.Arg -> Result
transArg x = case x of
  AbsBing.VArg expr -> failure x
  AbsBing.PArg ident -> failure x

transExpr :: AbsBing.Expr -> Result
transExpr x = case x of
  AbsBing.EVar ident -> failure x
  AbsBing.ELitInt integer -> failure x
  AbsBing.ELitTrue -> failure x
  AbsBing.ELitFalse -> failure x
  AbsBing.EApp ident args -> failure x
  AbsBing.EString string -> failure x
  AbsBing.Neg expr -> failure x
  AbsBing.Not expr -> failure x
  AbsBing.EMul expr1 mulop expr2 -> failure x
  AbsBing.EAdd expr1 addop expr2 -> failure x
  AbsBing.ERel expr1 relop expr2 -> failure x
  AbsBing.EAnd expr1 expr2 -> failure x
  AbsBing.EOr expr1 expr2 -> failure x

transAddOp :: AbsBing.AddOp -> Result
transAddOp x = case x of
  AbsBing.Plus -> failure x
  AbsBing.Minus -> failure x

transMulOp :: AbsBing.MulOp -> Result
transMulOp x = case x of
  AbsBing.Times -> failure x
  AbsBing.Div -> failure x
  AbsBing.Mod -> failure x

transRelOp :: AbsBing.RelOp -> Result
transRelOp x = case x of
  AbsBing.LTH -> failure x
  AbsBing.LE -> failure x
  AbsBing.GTH -> failure x
  AbsBing.GE -> failure x
  AbsBing.EQU -> failure x
  AbsBing.NE -> failure x
